# CryptoChronic v1.0

CryptoChronic is a multi-platform video-game, built upon and evolving around non-fungible (ERC721) tokens called "Chronics" that represents toonish minions composed by marijuana strains.

from https://www.cryptochronic.com/


<p align="center">
  <img alt="Dark" src="https://static.wixstatic.com/media/0e15a6_2215c433545343c1bb8cf1ef857a5307~mv2.png/v1/fill/w_470,h_669,al_c,q_85,usm_0.66_1.00_0.01,enc_auto/0e15a6_2215c433545343c1bb8cf1ef857a5307~mv2.png" width="100%">
</p>

### Built With

* [Solidity](https://docs.soliditylang.org/)
* [Hardhat](https://hardhat.org/getting-started/)

## Chronic Token

A Chronic is a combination of 7 layers of different parts

    - body
    - eyes
    - mouth
    - headgear
    - arms
    - leaves
    - vase

<p align="center">   <img alt="Dark" src="https://static.wixstatic.com/media/0e15a6_b376a6afa69c459fb8597d712656db3e~mv2.png/v1/fill/w_360,h_664,al_c,q_85,usm_0.66_1.00_0.01,enc_auto/Personaggio_4_v3.png" width="100%"> </p>

For each layer can be defined a variable number of parts, each of them identified by an unique ID. Other than defining their shape the combination of different parts set the following battle stats of the token:

- var/actual THC
- var/actual CBD
- var/actual Aroma

The `actual` means the starting value of the Chronic, the `var` set the upper and the lower value that a Chronic can have in the game life. Those variations happen off-chain and aren't recorded on-chain.

*for instance a Chronic has 40 actual CBD and 12 of var: this means that during the game it can't have more than 52 or below 28.*

Each layer's part that compose the Chronic add it's own values to the total. 

Each Chronic belongs to a series, at the moment there will be only the 0 series, the original one.

The token data stored on-chain are called `genes` of the Chronic and it's uint 32 byte number that must be parsed with the following bit pattern: (at the moment only the first 22 bytes are used)

Bytes

| 22-21 | 20-19 | 18-17 | 16-15 | 14-13 | 12-11 | 10-9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| actual aroma | var aroma |  actual CBD | var CBD | actual THC | var THC | generation | (TBD) | ID vase | ID leaves | ID arms | ID headgear | ID mouth | ID eyes | ID body | series |

This implies that can be a maximum of 255 part IDs for each layers, so the possible series and the battle stats values can be maximum 65535.

When minted the Chronic is generated by the Breeder contract and each part is picked according to a random weighted on the part's rarity. A minted Chronic will be always considered of "first generation", so the corresponding value in it's gene will be 1, and thus it's fertility will be equal to a predefined value set in the contract.

A Chronic can be bred, mixing the genes of two parent Chronics; the generation is still random but the parts of the parents have more weight and so more chance to be picked. A bred Chronic is of a subsequent generation of the youngest of its parent and thus its fertiliy is equal to the predefined value set in the contract divided and floored by its generation. The initial fertility of a Chronic however can not be lower than 1.

*for instance two Chronics are combined in a breed: the first has a generation of 1 and the second has a generation of 3; the base value of fertility is 10. The new Chronic will have generation 4 and an initial fertility of 2*

Each time a Chronic is involved in a breeding as a parent, its ferility is decreased by 1.

Other related information, such as the name of the Chronic, are off-chain and a base token and image URIs can be set in the contract to provide a link to those metadata files.

Finally, a Chronich can be crafted by the owner of the contract ad assinged to an address. While crafting the caller can decide exactly the gene, the initial fertility and the series.

## Solidity contracts

The architecture is built upon 3 contracts

- Chronic: a IERC721 contract that holds the Chronics data
- Breeder: a contract responsible of the random generation of the Chronics
- Feeder: a contract with the functions related to manage the fertility of the Chronics

The contracts relies on OpenZeppelin's ERC721Enumerable, Counter, Ownable, Pausable parent contracts 
### Chronic

#### Roles and functions

The contract has:

- an Owner (the address that deploy the contract) that can
    - pause(**) the contract (by default the contract is not paused)
    - unpause(*) the contract
    - disableCraft (by default crafting is enabled)
    - freeze changes of the base URIs (by default they can be changed)
    - set a new Breeder(*) (initially set at deploy time)
    - set a new Feeder(*) (initially set at deploy time)
    - set a new Freezer(*) (initially set at deploy time)
    - set a new minium token that a new player must have(*) (default at 3)
    - set the base URI for token, image and contract(*)
    - craft a Chronic with a specific gene(**) (if crafting is enabled)

- a Breeder (set at deploy time, an instance of the Breeder contract) that can
    - mint a new Chronic(**) for a specific address
    - decrease the fertility of a Chronic(**)

- a Feeder (set at deploy time, an instance of the Feeder contract) that can
    - increase the fertility of a Chronic(**)

- a Freezer (set at deploy time, a wallet) that can
    - set the ID of a tokenID(**) in another blockchain
    - unfreeze a Chronic(**), it means it can transfer it from his wallet to a specific address

And the following public functions

- transfer functions of the IERC721 but that can be activated only if the caller is not the Freezer and if it has as more than the minimum tokens
- freeze a Chronic(**) that means the token is transferred to the Freezer wallet
- tokenURI that returns the string baseTokenURI + tokenID + '.json' where the Chronic metadata are located
- imageURI that returns the string baseImageURI + tokenID + '.png' where the Chronic image file is located
- contractURI that returns the URI where the metadata of the contract are located
- get the last minted Chronic tokenID, since the ID is incremental it means the minted amount

(*) only when the contract is paused; (**) only when the contract is not paused

### Mapping

The token data are stored in 3 public mappings which keys is the tokenID

    - genes: a uint256 holding information on the body parts and the battle stats of the Chronic
    - fertility: the current value of fertility of a Chronic
    - parents: a uint256 tuple with the tokenID of the two parent of a Chronic ([0,0] if it doesn't have any)
    - otherBC: a uint256 with the tokenID of a frozen Chronic in another blockchain

### Breeder

#### Roles and functions

The contract has:

- an Owner (the address that deploy the contract) that can
    - pause(**) the contract (the contract is paused at deploy time)
    - unpause(*) the contract
    - set Chronic Contract(*) with the new address of the bound Chronic contract (none set at deploy time)
    - set the price(*) for players to breed two of their Chronic (default at 0.5 ether)
    - set the price(*) for players to mint a new Chronic (default at 1 ether)
    - set the default fertility(*) of Chronics (default at 10)
    - set the whole dataset(*) of the different layers that compose the Chronics and the base of their battle
    - update a single layer values(*)
    - update a single part values of a specific layer(*)
    - update the series of the Chronic(*) (default at 0)
    - set the whole weight system(*) of the layers used in the generation of a Chronic 
    - mint and assign(*) an amount of Chronic equal to the `initialTokens` value in the Chronic contract (this function reverts unless the address has no tokens, it's purpose is the onboaring of new players)
    - breed and assign(**) a Chronic to an address using two of its token
    - withdraw(**) the funds in native coin that belongs to the contract
    
And the following public function

    - breed(**) that generates a new Chronic given two parents token hold by the caller, who pays the breed price
    - get the strcutured representation of a Chronic decodifiyng it's gene

(*) only when the contract is paused; (**) only when the contract is not paused

### Feeder

#### Roles and functions

The contract has:

- an Owner (the address that deploy the contract) that can
    - pause(**) the contract (the contract is paused at deploy time)
    - unpause(*) the contract
    - set Chronic Contract(*) with the new address of the bound Chronic contract (none set at deploy time)
    - set the price(*) for players of a fertility increase by 1 of one of their Chronic (default at 0.25 ether)
    - withdraw(**) the funds in native coin that belongs to the contract

And the following public function

    - increase the fertility(**) of a Chronic hold by the caller, who pays the increase fertility price

(*) only when the contract is paused; (**) only when the contract is not paused

## Utilities

A sample of the layer data in JSON is provided and helpers function in Javascript to parse this source and generate the proper inputs for the `setLayers` and the `setWeights` methods (the function `encodeLayers`) and the `craft` functions (the function `encodeGene`).

### Layer data

The data are in an object which keys are the single layer and the values an array of `parts`

```
{
    "body": [],
    "eyes": [],
    "mouth": [],
    "headgear":[],
    "arms": [],
    "leaves":[],
    "vase":[]
}
```

A `part` is an object with the following structure (values are just illustrative)

```
{
    "id": 1,
    "rarity": 2,
    "battle": {
        "thc": {
            "var": 5,
            "actual": 15
        },
        "cbd": {
            "var": 0,
            "actual": 10
        },
        "aroma": {
            "var": 3,
            "actual": 9
        }
    }
}
```
- ID: is an arbitray unique per layer number between 1-255
- Rarity: is a number between 1-4 (1=common, 4=ultra-rare)
- Var/Actual: the battle stats related value of the part

The generation algorithm will set a single part for each of the seven layers with a weight pseudo-random depending on the rarities in each layer. When breeding the pseudo-random is also affected by the parents Chronic which parts have more chance to be picked.

The values of each layer's part are summed, for instance, if the picked body part has actualTCH of 50 and the picked eyes has actualTHC of 5, the actualTHC is 55, and so on, each following part after body add its values.

### Weights system

Each rarity level has a `rarity coefficient` defined in javascript utility library and used in the function `encodeLayers` that returns an array of arrays which indexing matches the structure of the encoded layers and the values are calculated multiplying the coefficient and the number of parts in the layer with the same rarity level. The returned array must be used as a input of the `setWeights` method of the Breeder.


## Contact

for more info email at Info@cryptochronic.com 
or go to https://https://www.cryptochronic.com/

## Social 

Discord:   https://discord.gg/ArHNbvHMh7

Twitter:   https://twitter.com/CryptoChronic1

Facebook:  https://www.facebook.com/CryptoChronicCannaverse/

## License

See LICENSE for more information.
